Threading: DONE
	GameThread:
	- Will run as long as the render queue is not full
	- 2 Phases:
		1. Update the game
		2. Submiting objects to the render module
	RenderThread:
	- Will run as long as there are frames in the render queue
	- Multiple passes:
		1. Takes all objects submitted from the game thread and sends
		2. Post Processing
		3. This completely depends on the renderer and may even be a scriptable pipeline?

Modules: DONE
	- Modules could choose what thread they run on
	- Some modules may not require an update per frame
	- Modules know nothing about other modules
	- They may use other abstract modules from the core engine for external functionality, but never knows the full implementation of the module

ScenesModule:
	- Runs on the GameThread
	- Contains all the objects within a loaded scene
	- In charge of handling serialization and deserialization of scenes
	- Runs on the game thread in 2 phases:
		1. Update the loaded scene(s) and all their objects
		2. Submit all objects that need to be rendered to the RenderModule
	- When both phases are done it notifies the RenderModule that the frame is finished
	- Does not know anything about the rendering implementation!

RenderModule:
	- Runs on the RenderThread
	- Keeps track of a RenderFrame
	- RenderFrame stores Objects that need to be rendered and their render settings
	- Does not know anything about the graphics API or platform!
	- Once a frame is ready it sends commands to the GraphicsModule

GraphicsModule:
	- Has a built in resource manager to manage resources that exist in GPU memory
	- Needs to be able to take resources from the core engine and convert them to GPU resources
	- Has no update loop
	- Takes in commands and sends them to the GPU based on the platform implementation
	- Does not do ANYTHING by itself!!! (hence why it has no update loop)

EntitySystems:
	- Add a callback for when the game starts and for when the component is added?

MaterialData:
	- Data version of the material, only holds the information about the shader
	- Array of ShaderData pointers
	- Property data, properties will be read through shaderc reflection

Material:
	- Created via a MaterialData object
	- Each API implementation implements its own Material
	- Holds an array of pointers to Shader objects
	- Functions for setting basic shader resources like world, view and projection matrices
	- Has a single function to set all other resources/properties
	- Caches values of properties/resources and sends them to the GPU when the material is used

Dumping objects ->
{220} normal block at 0x00E93520, 8 bytes long.
 Data: <        > D4 F7 CD 00 00 00 00 00 
{217} normal block at 0x00E8FFB0, 4 bytes long.
 Data: <P_  > 50 5F E7 00 
{212} normal block at 0x00E934E8, 8 bytes long.
 Data: <      @ > C0 A9 E8 00 F9 D9 40 00 
{159} normal block at 0x00E8A780, 16 bytes long.
 Data: <        P       > D8 0A E8 00 20 FF E8 00 50 FF E8 00 80 FF E8 00 
{158} normal block at 0x00E8F2B8, 8 bytes long.
 Data: <` I     > 60 C0 49 00 00 00 00 00 
{153} normal block at 0x00E8F398, 8 bytes long.
 Data: <D I     > 44 C0 49 00 00 00 00 00 
Object dump complete.